{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "from collections import OrderedDict as ordict\n",
    "import itertools\n",
    "import numpy as np\n",
    "from openfermion.chem import MolecularData\n",
    "from mindquantum.core.operators import FermionOperator\n",
    "from mindquantum.core.operators.utils import down_index, up_index\n",
    "from mindquantum.algorithm.nisq.chem.transform import Transform\n",
    "from mindquantum.core.circuit.utils import decompose_single_term_time_evolution\n",
    "from mindquantum.core.circuit import Circuit\n",
    "from mindquantum.third_party.interaction_operator import InteractionOperator\n",
    "from openfermionpyscf import run_pyscf\n",
    "from mindquantum.utils.type_value_check import _require_package\n",
    "from mindquantum.core.gates import X\n",
    "from mindquantum.core.operators import Hamiltonian\n",
    "from mindquantum.simulator import Simulator\n",
    "import mindspore as ms\n",
    "import random\n",
    "from scipy.optimize import minimize\n",
    "from mindquantum.algorithm.nisq import generate_uccsd\n",
    "from mindquantum.core.circuit import AP, UN\n",
    "from mindquantum.core.operators import QubitOperator\n",
    "from mindquantum.algorithm.nisq.chem import get_qubit_hamiltonian\n",
    "\n",
    "# np.set_printoptions(threshold=np.inf)\n",
    "TOLERANCE = 1e-8\n",
    "\n",
    "ms.set_context(mode=ms.PYNATIVE_MODE, device_target=\"CPU\")\n",
    "# UCCSD源码\n",
    "def _para_uccsd_singlet_generator(mol, th=0):\n",
    "    \"\"\"\n",
    "    Generate a uccsd quantum circuit.\n",
    "\n",
    "    Args:\n",
    "        mol (molecular): A hdf5 molecular file generated by HiQ Fermion.\n",
    "        th (int, optional): A threadhold of parameters. If a parameter is\n",
    "            lower than the threadhold, than we will not update it in VQE\n",
    "            algorithm. Default: 0.\n",
    "    \"\"\"\n",
    "    # 从分子数据中获得量子位数和电子数\n",
    "    n_qubits = mol.n_qubits\n",
    "    n_electrons = mol.n_electrons\n",
    "    # 生成参数字典\n",
    "    params = {}\n",
    "    # 检查自选轨道数是否为偶数\n",
    "    if n_qubits % 2 != 0:\n",
    "        raise ValueError('The total number of spin-orbitals should be even.')\n",
    "    out = []\n",
    "    out_tmp = []\n",
    "    # 计算空间轨道数, 占据轨道数, 虚轨道数也就是未占据轨道数\n",
    "    n_spatial_orbitals = n_qubits // 2\n",
    "    n_occupied = int(np.ceil(n_electrons / 2))\n",
    "    n_virtual = n_spatial_orbitals - n_occupied\n",
    "\n",
    "    # Unpack amplitudes\n",
    "    # 单激发的数量\n",
    "    n_single_amplitudes = n_occupied * n_virtual\n",
    "    # Generate excitations\n",
    "    # 自旋函数\n",
    "    spin_index_functions = [up_index, down_index]\n",
    "    # Generate all spin-conserving single and double excitations derived\n",
    "    # from one spatial occupied-virtual pair\n",
    "    # 遍历所有的占据轨道和未占据轨道的组合\n",
    "    for i, (p, q) in enumerate(\n",
    "            itertools.product(range(n_virtual), range(n_occupied))):\n",
    "\n",
    "        # P和Q分别是未占据轨道和占据轨道的索引\n",
    "        # Get indices of spatial orbitals\n",
    "        # 未占据轨道的索引\n",
    "        virtual_spatial = n_occupied + p\n",
    "        # 占据轨道的索引\n",
    "        occupied_spatial = q\n",
    "        # 对应自旋向上的虚轨道和占据轨道的索引\n",
    "        virtual_up = virtual_spatial * 2\n",
    "        occupied_up = occupied_spatial * 2\n",
    "        # 对应自旋向下的虚轨道和占据轨道的索引\n",
    "        virtual_down = virtual_spatial * 2 + 1\n",
    "        occupied_down = occupied_spatial * 2 + 1\n",
    "        # 初始化单激发和双激发的振幅\n",
    "        single_amps = 0.0\n",
    "        double1_amps = 0.0\n",
    "        # single_amps = mol.ccsd_single_amps[virtual_up, occupied_up]\n",
    "        # double1_amps = mol.ccsd_double_amps[virtual_up, occupied_up, virtual_down, occupied_down]\n",
    "        # 生成单激发和双激发的名字\n",
    "        single_amps_name = 'p' + str(i)\n",
    "        double1_amps_name = 'p' + str(i + n_single_amplitudes)\n",
    "\n",
    "        # 遍历两种自旋\n",
    "        for spin in range(2):\n",
    "            # Get the functions which map a spatial orbital index to a\n",
    "            # spin orbital index\n",
    "            # 获取自旋函数\n",
    "            this_index = spin_index_functions[spin]\n",
    "            other_index = spin_index_functions[1 - spin]\n",
    "\n",
    "            # Get indices of spin orbitals\n",
    "            # 获取自旋向上和向下的虚轨道和占据轨道的索引\n",
    "            # This is 当前自旋状态\n",
    "            # Other is 另一种自旋状态\n",
    "            virtual_this = this_index(virtual_spatial)\n",
    "            virtual_other = other_index(virtual_spatial)\n",
    "            occupied_this = this_index(occupied_spatial)\n",
    "            occupied_other = other_index(occupied_spatial)\n",
    "\n",
    "            # Generate single excitations\n",
    "            # 如果单激发的振幅大于阈值, 则生成对应的单激发\n",
    "            if abs(single_amps) > th:\n",
    "                params[single_amps_name] = single_amps\n",
    "                fermion_ops1 = FermionOperator(\n",
    "                    ((occupied_this, 1), (virtual_this, 0)), 1)\n",
    "                fermion_ops2 = FermionOperator(\n",
    "                    ((virtual_this, 1), (occupied_this, 0)), 1)\n",
    "                out.append([fermion_ops1 - fermion_ops2, single_amps_name])\n",
    "\n",
    "            # Generate double excitation\n",
    "            # 如果双激发的振幅大于阈值, 则生成对应的双激发\n",
    "            if abs(double1_amps) > th:\n",
    "                params[double1_amps_name] = double1_amps\n",
    "                fermion_ops1 = FermionOperator(\n",
    "                    ((virtual_this, 1), (occupied_this, 0), (virtual_other, 1),\n",
    "                     (occupied_other, 0)), 1)\n",
    "                fermion_ops2 = FermionOperator(\n",
    "                    ((occupied_other, 1), (virtual_other, 0),\n",
    "                     (occupied_this, 1), (virtual_this, 0)), 1)\n",
    "                out.append([fermion_ops1 - fermion_ops2, double1_amps_name])\n",
    "    out.extend(out_tmp)\n",
    "    out_tmp = []\n",
    "    # Generate all spin-conserving double excitations derived\n",
    "    # from two spatial occupied-virtual pairs\n",
    "    # 为了生成双激发, 需要遍历两种不同占据轨道和两种不同未占据轨道的组合\n",
    "    # 使用itertools.product和itertools.combinations生成两个占据轨道和两个未占据轨道的组合\n",
    "    for i, ((p, q), (r, s)) in enumerate(\n",
    "            itertools.combinations(\n",
    "                itertools.product(range(n_virtual), range(n_occupied)), 2)):\n",
    "\n",
    "        # Get indices of spatial orbitals\n",
    "        # 计算两个占据轨道和两个未占据轨道的索引\n",
    "        virtual_spatial_1 = n_occupied + p\n",
    "        occupied_spatial_1 = q\n",
    "        virtual_spatial_2 = n_occupied + r\n",
    "        occupied_spatial_2 = s\n",
    "\n",
    "        # 为这些轨道计算出自旋向上和自旋向下的索引\n",
    "        virtual_1_up = virtual_spatial_1 * 2\n",
    "        occupied_1_up = occupied_spatial_1 * 2\n",
    "        virtual_2_up = virtual_spatial_2 * 2 + 1\n",
    "        occupied_2_up = occupied_spatial_2 * 2 + 1\n",
    "\n",
    "        # 初始化双激发的振幅\n",
    "        double2_amps = 0.0\n",
    "        # double2_amps = mol.ccsd_double_amps[virtual_1_up, occupied_1_up, virtual_2_up, occupied_2_up]\n",
    "        # 生成双激发的名字\n",
    "        double2_amps_name = 'p' + str(i + 2 * n_single_amplitudes)\n",
    "\n",
    "        # Generate double excitations\n",
    "        # 使用itertools.product遍历所有的自旋组合\n",
    "        for (spin_a, spin_b) in itertools.product(range(2), repeat=2):\n",
    "            # Get the functions which map a spatial orbital index to a\n",
    "            # spin orbital index\n",
    "            index_a = spin_index_functions[spin_a]\n",
    "            index_b = spin_index_functions[spin_b]\n",
    "\n",
    "            # Get indices of spin orbitals\n",
    "            # 计算自旋向上和自旋向下的虚轨道和占据轨道的索引\n",
    "            virtual_1_a = index_a(virtual_spatial_1)\n",
    "            occupied_1_a = index_a(occupied_spatial_1)\n",
    "            virtual_2_b = index_b(virtual_spatial_2)\n",
    "            occupied_2_b = index_b(occupied_spatial_2)\n",
    "            # 如果双激发的振幅大于阈值, 则生成对应的双激发\n",
    "            # 这些算符包含两个电子从两个不同的占据轨道跃迁到两个不同的虚拟轨道的操作，以及其相反操作。\n",
    "            if abs(double2_amps) > th:\n",
    "                params[double2_amps_name] = double2_amps\n",
    "                fermion_ops1 = FermionOperator(\n",
    "                    ((virtual_1_a, 1), (occupied_1_a, 0), (virtual_2_b, 1),\n",
    "                     (occupied_2_b, 0)), 1)\n",
    "                fermion_ops2 = FermionOperator(\n",
    "                    ((occupied_2_b, 1), (virtual_2_b, 0), (occupied_1_a, 1),\n",
    "                     (virtual_1_a, 0)), 1)\n",
    "                # 生成的费米子算符和其参数名字添加到out中\n",
    "                out.append([fermion_ops1 - fermion_ops2, double2_amps_name])\n",
    "    # 返回费米子算符和参数名字\n",
    "    return out, params\n",
    "\n",
    "\n",
    "# 将费米子算符转换为泡利算符,基于jordan-wigner变换\n",
    "# 参数是一个费米子算符的列表\n",
    "def _transform2pauli(fermion_ansatz):\n",
    "    \"\"\"\n",
    "    Transform a fermion ansatz to pauli ansatz based on jordan-wigner\n",
    "    transformation.\n",
    "    \"\"\"\n",
    "    # 创建一个有序的空字典\n",
    "    out = ordict()\n",
    "    # 遍历费米子算符列表\n",
    "    for i in fermion_ansatz:\n",
    "        # 对每一个费米子算符进行jordan-wigner变换\n",
    "        qubit_generator = Transform(i[0]).jordan_wigner()\n",
    "        # 如果变换后的泡利算符不为空, 则遍历其项,并根据算符的键值对更新out字典\n",
    "        if qubit_generator.terms != {}:\n",
    "            for key, term in qubit_generator.terms.items():\n",
    "                if key not in out:\n",
    "                    out[key] = ordict({i[1]: float(term.imag)})\n",
    "                else:\n",
    "                    if i[1] in out[key]:\n",
    "                        out[key][i[1]] += float(term.imag)\n",
    "                    else:\n",
    "                        out[key][i[1]] = float(term.imag)\n",
    "    return out\n",
    "\n",
    "\n",
    "# 将泡利算符转换为参数化量子电路\n",
    "def _pauli2circuit(pauli_ansatz):\n",
    "    \"\"\"Transform a pauli ansatz to parameterized quantum circuit.\"\"\"\n",
    "    circuit = Circuit()\n",
    "    # 遍历泡利算符的项\n",
    "    # 对每个泡利算符项, 使用decompose_single_term_time_evolution函数生成对应的参数化量子电路\n",
    "    # k是泡利算符的键,表示特定的量子比特操作, v是泡利算符的值,表示操作的参数\n",
    "    for k, v in pauli_ansatz.items():\n",
    "        circuit += decompose_single_term_time_evolution(k, v)\n",
    "    return circuit\n",
    "\n",
    "\n",
    "def generate_uccsd(molecular, threshold=0):\n",
    "    \"\"\"\n",
    "    Generate a uccsd quantum circuit based on a molecular data generated by Openfermion.\n",
    "\n",
    "    Args:\n",
    "        molecular (Union[str, MolecularData]): the name of the molecular data file,\n",
    "            or openfermion MolecularData.\n",
    "        threshold (float): the threshold to filter out the uccsd amplitude. We only keep the\n",
    "            excitation operator with absolute value of amplitude greater than `threshold`, so\n",
    "            that if `threshold=0`, we only keep excitation operator with non zero amplitude. Default: ``0``.\n",
    "\n",
    "    Returns:\n",
    "        - **uccsd_circuit** (Circuit), the ansatz circuit generated by uccsd method.\n",
    "        - **initial_amplitudes** (numpy.ndarray), the initial parameter values of uccsd circuit.\n",
    "        - **parameters_name** (list[str]), the name of initial parameters.\n",
    "        - **qubit_hamiltonian** (QubitOperator), the hamiltonian of the molecule.\n",
    "        - **n_qubits** (int), the number of qubits in simulation.\n",
    "        - **n_electrons** (int), the number of electrons of the molecule.\n",
    "    \"\"\"\n",
    "    try:\n",
    "        # pylint: disable=import-outside-toplevel\n",
    "        from openfermion.chem import MolecularData\n",
    "    except (ImportError, AttributeError):\n",
    "        _require_package(\"openfermion\", \"1.5.0\")\n",
    "    if isinstance(molecular, str):\n",
    "        mol = MolecularData(filename=molecular)\n",
    "        mol.load()\n",
    "    else:\n",
    "        mol = molecular\n",
    "    print(f\"ccsd:{mol.ccsd_energy}.\")\n",
    "    print(f\"fci:{mol.fci_energy}.\")\n",
    "    fermion_ansatz, parameters = _para_uccsd_singlet_generator(mol, threshold)\n",
    "    pauli_ansatz = _transform2pauli(fermion_ansatz)\n",
    "    uccsd_circuit = _pauli2circuit(pauli_ansatz)\n",
    "    ham_of = mol.get_molecular_hamiltonian()\n",
    "    inter_ops = InteractionOperator(*ham_of.n_body_tensors.values())\n",
    "    ham_hiq = FermionOperator(inter_ops)\n",
    "    qubit_hamiltonian = Transform(ham_hiq).jordan_wigner()\n",
    "    qubit_hamiltonian = qubit_hamiltonian.compress()\n",
    "\n",
    "    parameters_name = list(parameters.keys())\n",
    "    initial_amplitudes = [parameters[i] for i in parameters_name]\n",
    "    return uccsd_circuit, initial_amplitudes, parameters_name, qubit_hamiltonian, mol.n_qubits, mol.n_electrons\n",
    "def generate_uccsd_pool(molecular, th=0):\n",
    "    if isinstance(molecular, str):\n",
    "        mol = MolecularData(filename=molecular)\n",
    "        mol.load()\n",
    "    else:\n",
    "        mol = molecular\n",
    "    # 使用_para_uccsd_singlet_generator函数生成费米子算符和参数名字\n",
    "    fermion_ansatz, parameters = _para_uccsd_singlet_generator(mol, th)\n",
    "\n",
    "    # print(f\"ccsd:{mol.ccsd_energy}.\")\n",
    "    # print(f\"fci:{mol.fci_energy}.\")\n",
    "    operator_pools = []\n",
    "    circuit_pools = []\n",
    "    # 遍历费米子算符,使用_transform2pauli函数将费米子算符转换为泡利算符\n",
    "    for i, item in enumerate(fermion_ansatz):\n",
    "        pauli_ansatz = _transform2pauli([item])\n",
    "        circuit = Circuit()\n",
    "        # 遍历泡利算符的项\n",
    "        for k, v in pauli_ansatz.items():\n",
    "            # 使用decompose_single_term_time_evolution函数生成对应的参数化量子电路\n",
    "            circuit += decompose_single_term_time_evolution(k, v)\n",
    "        # 如果量子电路不为空, 则将费米子算符和量子电路添加到对应的列表中\n",
    "        if len(circuit) > 0:\n",
    "            operator_pools.append(Transform(item[0]).jordan_wigner())\n",
    "            circuit_pools.append(circuit)\n",
    "\n",
    "    # 返回泡利算符和参数化量子电路\n",
    "    return operator_pools, circuit_pools\n",
    "def generate_qeb_ccsd_pool(molecular, th=0):\n",
    "    if isinstance(molecular, str):\n",
    "        mol = MolecularData(filename=molecular)\n",
    "        mol.load()\n",
    "    else:\n",
    "        mol = molecular\n",
    "    # 使用_para_uccsd_singlet_generator函数生成费米子算符和参数名字\n",
    "    fermion_ansatz, parameters = _para_uccsd_singlet_generator(mol, th)\n",
    "\n",
    "    operator_pools = []\n",
    "    circuit_pools = []\n",
    "\n",
    "    for i, item in enumerate(fermion_ansatz):\n",
    "        pauli_ansatz = _transform2pauli([item])\n",
    "        circuit = Circuit()\n",
    "        modified_operator = QubitOperator()\n",
    "        for k, v in pauli_ansatz.items():\n",
    "            k0 = []\n",
    "            for kk in k:\n",
    "                if kk[1] != 'Z':\n",
    "                    k0.append(kk)\n",
    "                    # modified_operator += QubitOperator(f\"{kk[1]}{kk[0]}\", v)\n",
    "            k0 = tuple(k0)\n",
    "            circuit += decompose_single_term_time_evolution(k0, v)\n",
    "        if len(circuit) > 0:\n",
    "            operator_pools.append(Transform(item[0]).jordan_wigner())\n",
    "            # operator_pools.append(modified_operator)\n",
    "            circuit_pools.append(circuit)\n",
    "\n",
    "    return operator_pools, circuit_pools\n",
    "def generate_qubit_ccsd_pool(molecular, th=0):\n",
    "    if isinstance(molecular, str):\n",
    "        mol = MolecularData(filename=molecular)\n",
    "        mol.load()\n",
    "    else:\n",
    "        mol = molecular\n",
    "    # 使用_para_uccsd_singlet_generator函数生成费米子算符和参数名字\n",
    "    fermion_ansatz, parameters = _para_uccsd_singlet_generator(mol, th)\n",
    "\n",
    "    operator_pools = []\n",
    "    circuit_pools = []\n",
    "\n",
    "    for i, item in enumerate(fermion_ansatz):\n",
    "        pauli_ansatz = _transform2pauli([item])\n",
    "        circuit = Circuit()\n",
    "        for k, v in pauli_ansatz.items():\n",
    "            modified_operator = QubitOperator()\n",
    "            k0 = []\n",
    "            for kk in k:\n",
    "                if kk[1] == 'Z':\n",
    "                    # 替换 'Z' 操作为 'I' 操作\n",
    "                    k0.append((kk[0], 'I'))\n",
    "                    # modified_operator += QubitOperator(f\"I{kk[0]}\", v)\n",
    "                    # 替换 'Z' 操作为 'I' 操作时，指定量子比特索引\n",
    "                    # modified_operator += QubitOperator(f\"I{kk[0]}\", v)\n",
    "\n",
    "                else:\n",
    "                    k0.append(kk)\n",
    "                    # modified_operator += QubitOperator(f\"{kk[1]}{kk[0]}\", v)\n",
    "            k0 = tuple(k0)\n",
    "            circuit += decompose_single_term_time_evolution(k0, v)\n",
    "            # circuit += decompose_single_term_time_evolution(modified_operator,v)\n",
    "            # for term in modified_operator:\n",
    "            #     if 'I' not in term:\n",
    "            #         circuit += decompose_single_term_time_evolution(term, v)\n",
    "        if len(circuit) > 0:\n",
    "            operator_pools.append(Transform(item[0]).jordan_wigner())\n",
    "            # operator_pools.append(modified_operator)\n",
    "            circuit_pools.append(circuit)\n",
    "\n",
    "    return operator_pools, circuit_pools\n",
    "# 目标函数\n",
    "def energy_obj(n_paras, energy, res_last={}):\n",
    "    # n_paras: 电路的参数，用于确定量子态。\n",
    "    # energy: 一个函数，接受 n_paras 作为输入，返回能量及其梯度。\n",
    "    # res_last: 用于存储上一次迭代的结果，是一个字典\n",
    "\n",
    "    # 计算当前参数下的能量和梯度\n",
    "    res_energy = energy(n_paras)\n",
    "    # f: 能量\n",
    "    # grad: 梯度\n",
    "    f = np.real(res_energy[0])[0][0]\n",
    "    grad = np.real(res_energy[1])[0][0]\n",
    "\n",
    "    # 如果上一次迭代的结果中没有 f_last，那么就将 f_last 设置为 0.0\n",
    "    if 'f_last' not in res_last:\n",
    "        res_last['f_last'] = 0.0\n",
    "\n",
    "    # 否则，意味着 f_last 用于存储上一次迭代的能量值\n",
    "    else:\n",
    "        res_last['f_last'] = res_last['f']\n",
    "\n",
    "    res_last['x'] = list(n_paras)\n",
    "    res_last['grad'] = list(grad)\n",
    "    # 并计算梯度的范数（即梯度向量的长度或大小），这可以帮助了解梯度的变化程度\n",
    "    res_last['grad_norm'] = np.sqrt(np.sum(grad**2))\n",
    "    res_last['f'] = f\n",
    "    # 返回能量和梯度\n",
    "    return f, grad\n",
    "\n",
    "\n",
    "def adapt_vqe(molecule,type='fermion'):\n",
    "    # 加载分子数据\n",
    "    # molecule.load()\n",
    "    # 输出hf能量，ccsd能量，fci能量\n",
    "    # 用于和后面的VQE结果进行对比\n",
    "    print(\"hf:{}.\".format(molecule.hf_energy))\n",
    "    print(\"ccsd:{}.\".format(molecule.ccsd_energy))\n",
    "    print(\"fci:{}.\".format(molecule.fci_energy))\n",
    "\n",
    "    # 根据分子数据生成哈密顿量\n",
    "    hamiltonian_QubitOperator = get_qubit_hamiltonian(molecule).real\n",
    "    # print(hamiltonian_QubitOperator)\n",
    "\n",
    "    # 创建HF态,作为初态,也是对基态能量的一种猜想\n",
    "    hf_circuit = UN(X, molecule.n_electrons)  # 1¦00001111⟩\n",
    "    # 创建空电路,就是整体用来优化的电路\n",
    "    total_circuit = Circuit()\n",
    "    # 将HF态加入到空电路中\n",
    "    total_circuit += hf_circuit\n",
    "\n",
    "    # 生成UCCSD的S和D池子\n",
    "    if type == 'fermion':\n",
    "        operator_pools, circuit_pools = generate_uccsd_pool(molecule, th=-1)\n",
    "    elif type == 'qubit':\n",
    "        operator_pools, circuit_pools = generate_qubit_ccsd_pool(molecule, th=-1)\n",
    "    else:\n",
    "        operator_pools, circuit_pools = generate_qeb_ccsd_pool(molecule, th=-1)\n",
    "        \n",
    "    # operator_pools, circuit_pools = generate_uccsd_pool(molecule, th=-1)\n",
    "    # operator_pools, circuit_pools = generate_qubit_ccsd_pool(molecule, th=-1)\n",
    "    # operator_pools, circuit_pools = generate_qeb_ccsd_pool(molecule, th=-1)\n",
    "\n",
    "    # 对易子的存储对象\n",
    "    commuts = []\n",
    "    # 对于每一个S和D池子中的项，都计算其与哈密顿量的对易子\n",
    "    for op_i in operator_pools:\n",
    "        commut = hamiltonian_QubitOperator * op_i - op_i * hamiltonian_QubitOperator\n",
    "        commut.compress()\n",
    "        # 将对易子加入到commuts中\n",
    "        commuts.append(commut.real)\n",
    "\n",
    "    # 创建模拟器 相当于Estimator\n",
    "    sim = Simulator('mqvector', molecule.n_qubits)\n",
    "    # 把大电路加入到模拟器中\n",
    "    sim.apply_circuit(total_circuit)\n",
    "    # 初始化梯度向量\n",
    "    op_grad = np.zeros(len(commuts))\n",
    "    for i, commut_i in enumerate(commuts):\n",
    "        grad = sim.get_expectation(Hamiltonian(commut_i))\n",
    "        # 这个梯度可以被理解为该对易子在当前量子状态下对整体系统能量的影响程度。\n",
    "        op_grad[i] = abs(float(grad.real))\n",
    "\n",
    "    # 对梯度向量进行排序\n",
    "    op_grad_sort_idx = op_grad.argsort()[::-1]\n",
    "    # 将梯度最大的项加入到大电路中\n",
    "    total_circuit += AP(circuit_pools[op_grad_sort_idx[0]], f'i{0}')\n",
    "    # 初始化参数\n",
    "    init_amplitudes = np.random.uniform(size=len(total_circuit.params_name))\n",
    "\n",
    "    # 初始化最终结果变量\n",
    "    final_res = 0.0\n",
    "    max_iter_num = 100\n",
    "    # 初始化用于存储每次迭代能量的列表\n",
    "    results = []\n",
    "    # 开始迭代\n",
    "    for iter_i in range(max_iter_num):\n",
    "        # print(total_circuit.summary())\n",
    "        # print(total_circuit.parameter_resolver())\n",
    "\n",
    "        # 每一轮都要重置模拟器\n",
    "        sim.reset()\n",
    "        # 计算当前参数下的能量和梯度\n",
    "        energy = sim.get_expectation_with_grad(\n",
    "            Hamiltonian(hamiltonian_QubitOperator), total_circuit)\n",
    "        # 存储优化结果\n",
    "        res_last = {}\n",
    "        # 使用BFGS来进行优化\n",
    "        # 这里的优化目标函数是energy_obj,init_amplitudes是初始参数,energy是能量函数,res_last是用于存储上一次迭代结果的字典\n",
    "        res = minimize(energy_obj,\n",
    "                       init_amplitudes,\n",
    "                       args=(energy, res_last),\n",
    "                       method='bfgs',\n",
    "                       options={'disp': False, 'return_all': False},\n",
    "                       jac=True,\n",
    "                       tol=1e-6)\n",
    "\n",
    "        # 打印当前迭代的结果\n",
    "        print(\"Step %3d energy %20.16f\" % (iter_i, float(res.fun)))\n",
    "        # print(\"Corresponding parameters:\\n{}\".format(res.x))\n",
    "        # 计算并存储当前能量与完全配置相互作用能量（FCI能量）之间的差异。\n",
    "        results.append(abs(float(res.fun)-molecule.fci_energy))\n",
    "\n",
    "        # 如果当前能量与上一次迭代的能量之间的差异小于阈值，那么就认为迭代已经收敛了\n",
    "        if abs(final_res - float(res.fun)) < TOLERANCE:\n",
    "            print(\"Iterative is convergence!\")\n",
    "            print(\"Final energy : %20.16f\" % (float(res.fun)))\n",
    "            print(\"Final error : %20.16f\" %\n",
    "                  (abs(molecule.fci_energy - float(res.fun))))\n",
    "            break\n",
    "        # 否则，就更新final_res为当前能量,并继续迭代,直到迭代收敛,或者达到最大迭代次数,finally_res就是迭代能量,收敛之前用于和当前能量进行比较\n",
    "        final_res = float(res.fun)\n",
    "\n",
    "        # 更新电路参数并计算新的梯度\n",
    "        # 使用优化后的参数res.x更新量子电路\n",
    "        # res.x包含了优化过程找到的参数值\n",
    "        # res.x: 在 minimize 函数完成优化后，res 对象包含了优化过程中产生的多种数据。\n",
    "        # 其中 res.x 是优化过程得到的最优参数值数组。这是一个标准的 scipy.optimize 返回值用法，其中 .x 属性包含了最终的优化参数。\n",
    "        sim.apply_circuit(total_circuit, res.x)\n",
    "        for i, commut_i in enumerate(commuts):\n",
    "            grad = sim.get_expectation(Hamiltonian(commut_i))\n",
    "            op_grad[i] = abs(float(grad.real))\n",
    "\n",
    "        op_grad_sort_idx = op_grad.argsort()[::-1]\n",
    "        # 向总电路中添加一个新的量子门操作\n",
    "        # AP是add_prefix的缩写,添加新的量子门操作,并且给这个操作添加一个前缀\n",
    "        total_circuit += AP(circuit_pools[op_grad_sort_idx[0]],\n",
    "                            f'i{iter_i + 1}')\n",
    "        # 初始化下一次迭代的参数\n",
    "        init_amplitudes = np.zeros(len(total_circuit.params_name))\n",
    "        # 将当前的优化参数赋值给新的参数列表\n",
    "        init_amplitudes[:-1:1] = res.x\n",
    "        # 为新添加的量子门操作随机生成一个参数\n",
    "        init_amplitudes[-1] = random.random()\n",
    "\n",
    "    return results"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Hi_VQE",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.18"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
